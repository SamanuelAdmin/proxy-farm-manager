"""
Manager for the Squid proxy server.
Configurator and dbus controller.
"""

import ipaddress
import os
import dbus
import shutil

from .networks_manager import NetworkInterface
from .settings import ManagerSettings



class ProxyConfigurator:
    """
        Configurator for safe and flexible configs.
    """

    def __init__(
            self, settings: ManagerSettings,
            path_to_squid: str="/etc/squid/squid.conf",
            service_name="squid.service"
    ):
        self.__settings = settings
        self.__pathToConfigs: str = path_to_squid
        self.__pathToBackup: str = self.__pathToConfigs + ".back"
        self.__serviceName = service_name

    @property
    def service_name(self): return self.__serviceName


    def backup(self) -> None:
        if os.path.exists(self.__pathToConfigs)
            shutil.copyfile(self.__pathToConfigs, self.__pathToBackup)

    def restore(self) -> None:
        shutil.copyfile(self.__pathToBackup, self.__pathToConfigs)


    def config(self, interfaces: list[NetworkInterface]) -> list[NetworkInterface]:
        """
            Create configs for squid proxy server and save it to path_to_squid.
            Returns list of networks interfaces which need to create.
            New ifaces parameters:
                Name: priface{index}
                Network: 10.122.{index}.0/24
                Gateway (server): 10.122.{index}.1 + DHCP
        """

        configs: str = ""  # config file content
        proxyInterfaces: list[NetworkInterface] = []

        if len(interfaces) > 254:
            raise Exception("Cannot create more than 254 interfaces!")

        # creating new ifaces for proxy
        for i in range(len(interfaces)):
            # i - index of new iface
            proxyInterfaces.append(
                NetworkInterface(
                    f"priface{i}", ipaddress.ip_interface(f"10.122.{i}.1/24")
                )
            )

        configs += "# [ AUTO GENERATED BY PROXY FARM FRAMEWORK ]\n\n"
        configs += f"http_port {self.__settings.port}\n"
        configs += "dns_v4_first on\n"
        configs += "dns_nameservers " + " ".join([dns for dns in self.__settings.nameservers]) + "\n"
        configs += "\n"

        for ifIndex in range(len(interfaces)):
            configs += f"acl {proxyInterfaces[ifIndex].name} src {proxyInterfaces[ifIndex].interface.network}\n"
            configs += f"tcp_outgoing_address {interfaces[ifIndex].interface.ip} {proxyInterfaces[ifIndex].name}\n"
            configs += f"http_access allow {proxyInterfaces[ifIndex].name}\n"
            configs += "\n"

        if self.__settings.deny:
            configs += "http_access deny all\n"

        # saving config
        self.backup()
        with open(self.__pathToConfigs, "w") as f:
            f.write(configs)

        return proxyInterfaces


class ProxyController:
    def __init__(self, configurator: ProxyConfigurator):
        self.__configurator = configurator

        # dbus usage
        self.__sysbus = dbus.SystemBus()
        # systemd connector
        self.__systemd1 = self.__sysbus.get_object(
            'org.freedesktop.systemd1', '/org/freedesktop/systemd1'
        )
        self.__systemdManager = dbus.Interface(self.__systemd1, 'org.freedesktop.systemd1.Manager')


    def start(self) -> bool:
        self.__systemdManager.StartUnit(self.__configurator.service_name, "replace")
        return True

    def stop(self) -> bool:
        self.__systemdManager.StopUnit(self.__configurator.service_name, "replace")
        return True
